diff --git a/Makefile.am b/Makefile.am
index ff0de9f8..112c5aa9 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -228,9 +228,14 @@ dist_tmux_SOURCES += image.c image-sixel.c
 endif
 
 if NEED_FUZZING
-check_PROGRAMS = fuzz/input-fuzzer
+check_PROGRAMS = fuzz/input-fuzzer fuzz/cmd-fuzzer
+
 fuzz_input_fuzzer_LDFLAGS = $(FUZZING_LIBS)
 fuzz_input_fuzzer_LDADD = $(LDADD) $(tmux_OBJECTS)
+
+fuzz_cmd_fuzzer_LDFLAGS = $(FUZZING_LIBS)
+fuzz_cmd_fuzzer_LDADD = $(LDADD) $(tmux_OBJECTS)
+
 endif
 
 # Install tmux.1 in the right format.
@@ -244,4 +249,4 @@ install-exec-hook:
 	fi
 	$(mkdir_p) $(DESTDIR)$(mandir)/man1
 	$(INSTALL_DATA) $(srcdir)/tmux.1.@MANFORMAT@ \
-		$(DESTDIR)$(mandir)/man1/tmux.1
+		$(DESTDIR)$(mandir)/man1/tmux.1
\ No newline at end of file
diff --git a/fuzz/cmd-fuzzer.c b/fuzz/cmd-fuzzer.c
new file mode 100644
index 00000000..4bb877c2
--- /dev/null
+++ b/fuzz/cmd-fuzzer.c
@@ -0,0 +1,104 @@
+#include <stddef.h>
+#include <assert.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <sanitizer/lsan_interface.h>
+#include "tmux.h"
+
+/* Max fuzzer size of input data */
+#define FUZZER_MAXLEN 1024
+
+/* Max number of command-line arguments
+   that can be extracted from parsing. */
+#define FUZZER_MAXARGS 64
+
+/* Tmux's global event loop */
+struct event_base *libevent;
+
+/* Command parsing result */
+struct cmd_parse_result *pr;
+
+/* Fuzzer entry point */
+int LLVMFuzzerTestOneInput(const u_char *data, size_t size) {
+  if (size > FUZZER_MAXLEN || size < 1)
+      return 0;
+  
+  /* Create a safe, null termianted buffer */
+  static char buf[FUZZER_MAXLEN];
+  size_t len = size < FUZZER_MAXLEN - 1 ? size : FUZZER_MAXLEN - 1;
+  memcpy(buf, data, len);
+  buf[len] = '\0';
+
+  // Create argc and argv for command line arguments
+  int argc = 0;
+  char *argv[FUZZER_MAXARGS + 1];
+
+  // Pointer to the buffer for tokenization
+  char *p = buf;
+
+  // Tokenize the Fuzzer generated data into arguments
+  while (argc < FUZZER_MAXARGS) {
+    // Split the string on delimiter characters
+    char *token = strsep(&p, " \t\r\n");
+    if (token == NULL)
+        break;
+    if (*token == '\0') // Skip empty tokens
+        continue; 
+
+    argv[argc++] = token;
+  }
+  argv[argc] = NULL;
+
+  // Skip empty input
+  if (argc == 0)
+    return 0;
+
+  // Convert arguments to tmux's argument structure
+  struct args_value	*values = args_from_vector(argc, argv);
+
+  // Parse the command line arguments
+  pr = cmd_parse_from_arguments(values, argc, NULL);
+  
+  // Free the command parse list if parsing was successful
+  if (pr->status == CMD_PARSE_SUCCESS) {    
+    cmd_list_free(pr->cmdlist);
+  }
+  
+  // Free parse result and arguments
+  free(pr->error);
+  args_free_values(values, argc);
+  free(values);
+
+  return 0;
+}
+
+/* Fuzzer initialization function */
+int LLVMFuzzerInitialize(int *argc, char ***argv) {
+    const struct options_table_entry *oe;
+    
+    /* Create global Tmux environment and options */
+    global_environ = environ_create();
+    global_options = options_create(NULL);
+    global_s_options = options_create(NULL);
+    global_w_options = options_create(NULL);
+    
+    /* Set default values for tmux's options */
+    for (oe = options_table; oe->name != NULL; oe++) {
+        if (oe->scope & OPTIONS_TABLE_SERVER)
+            options_default(global_options, oe);
+        if (oe->scope & OPTIONS_TABLE_SESSION)
+            options_default(global_s_options, oe);
+        if (oe->scope & OPTIONS_TABLE_WINDOW)
+            options_default(global_w_options, oe);
+    }
+
+    libevent = osdep_event_init();
+
+    
+    /* Initialize key input processing and bindings */
+    input_key_build();
+    key_bindings_init();
+        
+    return 0;
+}
\ No newline at end of file
diff --git a/fuzz/cmd-fuzzer.dict b/fuzz/cmd-fuzzer.dict
new file mode 100644
index 00000000..db33d46e
--- /dev/null
+++ b/fuzz/cmd-fuzzer.dict
@@ -0,0 +1,60 @@
+"new-session"
+"new"
+"attach-session"
+"attach"
+"detach"
+"kill-session"
+"kill-window"
+"kill-pane"
+"split-window"
+"splitw"
+"horizontal-split"
+"vertical-split"
+"select-pane"
+"select-window"
+"list-sessions"
+"list-windows"
+"list-panes"
+"next-window"
+"previous-window"
+"last-window"
+"swap-pane"
+"swap-window"
+"rename-window"
+"display-panes"
+"set-option"
+"show-options"
+"capture-pane"
+"copy-mode"
+"paste-buffer"
+"send-keys"
+"command-prompt"
+"find-window"
+"new-window"
+"choose-buffer"
+"choose-client"
+"choose-session"
+"list-clients"
+"list-keys"
+"load-buffer"
+"save-buffer"
+"refresh-client"
+"lock-session"
+"source-file"
+"clock-mode"
+"resize-pane"
+"select-layout"
+"move-pane"
+"break-pane"
+"join-pane"
+"-Tcopy-mode"
+"-2"
+"-A"
+"-c"
+"-f"
+"-L"
+"-l"
+"-S"
+"-N"
+"exit"
+"help"
\ No newline at end of file
diff --git a/fuzz/cmd-fuzzer.options b/fuzz/cmd-fuzzer.options
new file mode 100644
index 00000000..6caa0cfd
--- /dev/null
+++ b/fuzz/cmd-fuzzer.options
@@ -0,0 +1,4 @@
+[libfuzzer]
+max_len = 1024
+detect_leaks=0
+rss_limit_mb=12384
\ No newline at end of file
