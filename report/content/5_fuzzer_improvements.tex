In this section we describe the modifications and additions made to the fuzzing infrastructure to improve the two (currently) uncovered regions identified in part 2.

\subsection*{Overview}

Improvements to the code coverage were achieved by targeting the two specific previously uncovered code regions with two new harnesses.

\subsection*{Improvement of Region A: \textit{Arguments}}

This new harness tries to cover the \texttt{arguments.c} file which, as already explained in Part 2, is responsible for processing the command-line flags that are passed to the tmux executable. Given its importance and the fact that the old oss-fuzz harness has only a $5.82\%$ coverage on this file we decided to create a harness that specifically target this file.

To fuzz this file we created a completely new harness that tries to call as many functions as possible from this file. The first thing we do in this harness is to parse the bytes given by libfuzzer into 2 variables: \texttt{char **argv} and \texttt{int args}, which are the command-line arguments that are normally passed to a program. With these 2 variables we are able to call the function \texttt{args\_from\_vector} which will create a \texttt{struct args\_value *}. Subsequently we used this struct with a \texttt{struct args\_parse} (which we can create with the bytes given from libfuzzer) to call the
\texttt{args\_parse} function which will return a \texttt{struct args *}. This struct is needed for many functions in the \texttt{arguments.c} file, e.g. we can use this struct together with bytes from libfuzzer to call \texttt{args\_print, args\_has, args\_get, args\_first, args\_count, args\_value,  args\_first\_value, args\_next\_value,  args\_string, args\_copy, args\_percentage, args\_strtonum}. Many of these functions allocate some space on the heap calling \texttt{malloc}, so if a function fails or we don't have enough bytes from libfuzzer to call the subsequent functions then we perform a cleanup calling \texttt{free} (or \texttt{args\_free}) to avoid the LeakSanitizer to give us some errors.

To build the docker image, the harness and run the harness you should execute the script \texttt{run\_improve1.sh} from the root of this project.

This new harness reach a coverage of 66.62\% which is 60\% more than the previous harness. The previous harness didn't focus on working with the arguments so the only called functions were \texttt{args\_parse, args\_create, args\_free and args\_print}. Since our harness focuses on calling as more functions as possible from this file it's trivial to understand the reason why our harness covers much more region.

Further improvements for this file is to target the function \texttt{args\_make\_commands\_now} which, as the name suggests, is responsible for the execution of commands. This function could increase the coverage of this file by a lot, since it also calls other 3 functions in \texttt{arguments.c} (\texttt{args\_make\_commands\_prepare}, \texttt{args\_make\_commands} and \texttt{args\_make\_commands\_free}) that were not covered by our harness. We didn't target these functions because unlike the other functions that we targeted, these don't work with \texttt{struct args *} but instead with \texttt{struct cmd *} and \texttt{struct cmdq\_item *}.


\subsection*{Improvement of Region B: \textit{Command Parsing}}

The improvements of \textit{Region B} targets the parsing of user-provided arguments, command execution and command parsing logic in general.

The target is a code area called when commands from the user input, configuration file  or command-line arguments are translated into structured commands for execution, therefore it's an area directly in contact with the user input.

As the code inside \texttt{cmd-parse.c} is only covered partially in the current harness, and almost all of the other command specific files are not targeted (such as \texttt{cmd.c}, \texttt{key-bindings.c}, \texttt{cmd-bind-key.c}, \texttt{key-string.c}, ...), since their functions are never invoked, we decided to improve coverage in these areas. To achieve this, we added calls to several \texttt{cmd-parse.c} functions that are normally invoked during client creation, specifically in \texttt{client.c}. These functions are directly called by the user input, meaning that any input generated by the fuzzer can be  easily and reliably reproduced through a corresponding direct invocation of tmux. This gives the fuzzing test cases of improved area \textit{B} strong reproducibility.

The harness implementation consists of two main parts:
\begin{itemize}
    \item Transforming the fuzzer input, \texttt{const u\_char *data}, into a valid input format for the command parser target function, by parsing it into an argument count \texttt{argc} and an argument vector \texttt{argv}, similar to the standard command line inputs.
    \item Crafting argument parsing tmux structures, creating commands and parsing them using \texttt{cmd\_parse\_from\_arguments}. To ensure reproducibility this parts is created taking inspiration from the command line parsing that happens inside the \texttt{client\_main} function, which uses directly the user-provided command line arguments.

\end{itemize}
The call to \texttt{cmd\_parse\_from\_arguments} is a high level function that has lots of underlying new function calls. Therefore the fuzzer execution may branch into multiple \texttt{cmd-*.c} files, depending on the input provided. This because the \texttt{cmd\_parse\_from\_arguments} is the funciton responsible to parsing user-supplied command line arguments and therefore based on the specific command it handles control to the corresponding implementation file, so with that function call we can call a wide range of command-specific code paths in various \texttt{cmd-*.c} files.

In addition, the harness must initialize correctly global variables and free up all dynamically allocated data and struct to ensure the lack of errors or unexpected memory leaks.

To run the new harness two flags were added in the \texttt{cmd-fuzzer.options} file, the file containing the flags for the fuzzer (\textit{libFuzzer}). One of the flag is \texttt{detect\_leaks=0} and it pauses the leakage detection. The leakage detection was not taken into account, even if this causes missing memory leaks, because when running the new harness due to \texttt{cmd-parse.y} a memory leakage happens only after multiple runs due to the improper cleanup of the \texttt{static struct cmd\_parse\_state parse\_state} between successive parsing runs that triggers false positives in leak detection (as the leak detected in the Yacc parser file. These variables are static variables that retain state between parser invocations. This issue could be solved with either the new flag or by adding a Bison \href{https://www.gnu.org/software/bison/manual/html_node/Destructor-Decl.html}{\texttt{\%destructor} rule}.
Therefore leak checking was disabled to prioritize identifying critical crashes or bugs.
The other flag is an increase of the standard memory usage limit, \texttt{rss\_limit\_mb}, and it is added to avoid that an excessive use of memory (more than the standard \texttt{2048 MB} limit) causes the failure of libFuzzer.

To improve the fuzzing efficiency and guide libFuzzer input generation toward meaningful tmux command-line strings a dictionary file, \texttt{cmd-fuzzer.dict}, file was created. It contains tmux commands, options, aliases and flags commonly used (for example \texttt{"new-window", "split-window", "-h", ...}).

To build and run the new harness the script \texttt{run\_improve2.sh} should be executed; it clone and applies the adequate changes to the oss-fuzz repository such that the new harness is executed out of the box.

After fuzzing the project with the new harness for 4 hours the line-coverage and function coverage of the key parsing and dispatch code increased in the areas we targeted: \texttt{cmd-parse.c} jumped by $13.89\%$ in function coverage to $77.78 \% (28/36)$ and by $15.63\%$ in line coverage to $42.58\%$, reflecting the new parsing paths covered in out harness; \texttt{arguments.c}, the file responsible of interpreting command‚Äêline arguments, was increased in this harness too from $5.82\% (45/773)$ to $45.54 \% (352/773)$ and $47.62 \%$ in function coverage; \texttt{cmd.c} rose to $39.14 \%$ of line coverage and $45.45\%$ of function coverage.
Key-handling routines were now exercised in the new harness as:
\begin{itemize}
    \item \texttt{key-string.c} line coverage rose to $30.00\%$
    \item \texttt{key-bindings} line coverage rose to $56.05\% (278/496)$
\end{itemize}

Among individual command modules that were not touched by the previous harness but now are covered by the fuzzer tests:
\begin{itemize}
    \item \texttt{cmd-bind-key.c} and \texttt{cmd-set-options.c} achieved a function coverage of $50.00\%$;
    \item \texttt{cmd-command-prompt.c}, \texttt{cmd-confirm-before.c}, \texttt{cmd-if-shell.c} and \texttt{cmd-confirm-before.c} each reached a function coverage of $25.00\%$;
    \item \texttt{cmd-display-panes.c} attained a function coverage of $16.67\%$.
\end{itemize}
These modules were triggered by inputs passed to the \texttt{cmd\_parse\_from\_arguments} function, corresponding to specific commands that users can issue in tmux to invoke different functionalities.

A further possible improvement for \textit{region B} is to target a broader range of \texttt{cmd-*.c} or other specific command modules files by extending the new harness with additional function calls. This would enable coverage of command-releated operations involving windows, layouts, or panes for example. While such files are not invoked automatically by the new harness, executing the fuzzer for an extended period of time (as common done in research and industry scenarios) could further enhance the overall project coverage and include such code area too.
