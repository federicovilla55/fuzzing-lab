All experiments were performed on a Debian system with Linux kernel 6.1 (LTS), Docker 28.1.1, and Python 3.11. We used a local fork of OSS-Fuzz located at \texttt{forks/oss-fuzz}. To streamline execution, we developed two scripts---\texttt{run\_w\_corpus.sh} and \texttt{run\_wo\_corpus.sh}---that autonomously perform 4-hour fuzzing campaigns (with and without the seed corpus, respectively) and generate corresponding coverage reports. Both scripts are located in \texttt{submission/part\_1}. Their internal logic is modularized to share a common sequence of operations, which are detailed in the following subsections.

\noindent \paragraph{Configuration} \label{sec:methodology_configuration} Both scripts are highly configurable and can be run with different parameters. The following variables are set at the top of each script:
\begin{itemize}
	\item \texttt{PROJECT=tmux} -- OSS-Fuzz project name
	\item \texttt{HARNESS=input-fuzzer} -- name of the project's fuzzing harness to run
	\item \texttt{ENGINE=libfuzzer} -- engine to use (tmux supports
	      \href{https://llvm.org/docs/LibFuzzer.html}{\texttt{libfuzzer}},
	      \href{https://aflplus.plus/}{\texttt{afl++}}, and
	      \href{https://honggfuzz.dev/}{\texttt{honggfuzz}}).
	      \cite{oss-fuzz:tmux_project_yaml}
	\item \texttt{SANITIZER=address} -- Sanitizer to use. Available options:
	      \texttt{address} (\href{https://clang.llvm.org/docs/AddressSanitizer.html}{ASan}, \emph{default}),
	      \texttt{undefined} (\href{https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html}{UBSan}) or
	      \texttt{none} (disabled).
	      \cite{oss-fuzz:tmux_project_yaml}
	\item \texttt{REBUILD=true} -- controls whether to rebuild the OSS-Fuzz image from scratch.
	\item \texttt{RUNTIME=14400} -- fuzzing time in seconds (by default 4 hours).
	\item \texttt{FLAGS="-max\_total\_time=\$RUNTIME -timeout=25 -print\_final\_stats=1 -ignore\_crashes -artifact\_prefix=./crashes"} -- fuzzer engine flags (refer to the documentation of the engine for more details).
	\item \texttt{OSS\_FUZZ\_DIR="forks/oss-fuzz/build"} (\emph{optional}) â€“- this variable is set by default to match the current repository structure. However, it is still explicitly defined to allow advanced users to override it if they wish to customize the script for their own needs (e.g. use a different fork of OSS-Fuzz).
\end{itemize}

\noindent \textbf{Clean build directory} If \texttt{\$REBUILD} is true, we remove the entire \texttt{forks/oss-fuzz/build} directory as follows:

\begin{verbatim}
rm -rf "$OSS_FUZZ_DIR/build" || true
\end{verbatim}

This ensures no stale build artifacts remain and that the build process starts from a clean slate.

\noindent \paragraph{Apply patch (unseeded only)} \label{sec:methodology_patching} In \texttt{run\_wo\_corpus.sh} we remove the seed corpus from the Docker image and the build script to ensure the fuzzer starts with no initial input files, thus avoiding any bias introduced by pre-seeding the fuzzer with a starting corpus.

To achieve this, we apply a patch \texttt{remove\_seed\_corpus.patch} using the \texttt{git apply} command, which modifies the project's \texttt{Dockerfile} and \texttt{build.sh} to execlude the seed corpus during the build process:

\begin{verbatim}
git apply submission/part_1/
  remove_seed_corpus.patch
\end{verbatim}

\noindent \paragraph{Build OSS-Fuzz image and fuzzers} To prepare the fuzzing environment, we use the OSS-Fuzz helper script \texttt{helper.py} to build the Docker image and compile the fuzzers with the specified sanitizer (e.g., ASan, UBSan, none).

Before building the Docker image, the script checks whether rebuilding is required by evaluating the \texttt{\$REBUILD} variable (refer to \autoref{sec:methodology_configuration} for more details on the script configuration). If it is set to \texttt{true}, the following command is executed to build the Docker image for the configured project:

\begin{verbatim}
cd "$OSS_FUZZ_DIR"
python3 infra/helper.py build_image \
  "$PROJECT" --pull
\end{verbatim}

The \texttt{---pull} flag ensures that the latest version of the OSS-Fuzz base Docker image is used. This is essential to ensure compatibility with the latest updates, bug fixes, and dependency changes.

Regardless of the \texttt{\$REBUILD} variable, the script always rebuilds the fuzzers with the specified sanitizer using the following command:

\begin{verbatim}
python3 infra/helper.py build_fuzzers \
  "$PROJECT" --sanitizer "$SANITIZER" 
\end{verbatim}

This command compiles the fuzzers for the specified project, applying the selected sanitizer to instrument the code for better error detection and reporting. This generates the fuzzing binaries under \texttt{build/out/\$PROJECT}, which are later needed to run the fuzzing campaigns.

\noindent \paragraph{Prepare corpus directory}

By default, both scripts rely on \texttt{build/work/\$PROJECT/fuzzing\_corpus} as the input corpus directory (refer to \autoref{sec:methodology_configuration} for more details). For seeded runs, this directory is automatically populated by the unpatched \texttt{tmux}'s build scripts with files from the official \href{https://github.com/tmux/tmux-fuzzing-corpus/}{\texttt{tmux-fuzzing-corpus}} repository. This corpus provides a comprehensive set of input samples to simulate real-world usage scenarios and edge cases across different terminal emulators (currently only \href{https://iterm2.com/}{iTerm} and \href{https://alacritty.org/}{Alacritty}), including various terminal escape sequences and control characters. \cite{tmux:tmux-fuzzing-corpus}

On the other hand, during unseeded runs we ensure that the directory containing the seed corpus is empty. Even if the build script and Dockerfile are patched to exclude the seed corpus, the directory could still contain files from previous seeded runs. To ensure a clean state, we delete the \texttt{fuzzing\_corpus} directory and recreate it empty. In summary:

\begin{itemize}
	\item \emph{Seeded run:} leave whatever files OSS-Fuzz has placed there.
	\item \emph{Unseeded run:} delete and recreate it empty:
	      \begin{verbatim}
rm -rf "$CORPUS_DIR" || true
mkdir -p "$CORPUS_DIR/crashes"
\end{verbatim}
\end{itemize}

By default, we configured LibFuzzer to ensure that all crash-inducing inputs are stored within the designated \texttt{crashes} subdirectory. This is done by setting the \texttt{---artifact\_prefix} flag to \texttt{./crashes} in the \texttt{\$FLAGS} variable (refer to \autoref{sec:methodology_configuration} for more details). This allows us to easily access and analyze any inputs that caused the target program to crash during the fuzzing process.

\noindent \paragraph{Run the fuzzer (4 h)}

To start the fuzzing campaign with the configured fuzzer, we use the \texttt{run\_fuzzer} command provided by the OSS-Fuzz helper script. We explicitly set the fuzzing engine (e.g., \texttt{libfuzzer}), the input corpus directory, the target project, and the specific harness to be used. By default the fuzzer runs for 4 hours (14400 seconds), as specified by the \texttt{\$RUNTIME} variable.

\begin{verbatim}
python3 infra/helper.py run_fuzzer \
  --engine "$ENGINE" \
  --corpus-dir "build/work/\
    $PROJECT/fuzzing_corpus" \
  "$PROJECT" "$HARNESS" -- $FLAGS
    \end{verbatim}

To continue fuzzing even after crashes, we pass the \texttt{--ignore\_crashes} flag. This ensures that libfuzzer keeps running and exploring new paths even after finding a failure. Crashing inputs are still reported and saved in the \texttt{crashes} subdirectory, as defined by the fuzzer configuration.

\noindent \paragraph{Stop Docker}

To ensure that all Docker containers are stopped after the fuzzing campaign, we use the following command.

\begin{verbatim}
docker stop "$(docker ps -q)" || true
    \end{verbatim}

This is important to avoid leaving any running containers that may consume system resources or interfere with subsequent runs.

\noindent \paragraph{Export the corpus}

After each fuzzing campaign, we export the generated corpus from the \texttt{build/work/\$PROJECT/fuzzing\_corpus} directory to a zip file in the \texttt{experiments} directory, including in the filename the timestamp and the corpus type (seeded or unseeded). This step allows us to keep track of the corpus used in each run and facilitates further analysis or sharing of the corpus within the team.

\noindent \paragraph{Generate and export coverage report}

To generate the coverage report, we first rebuild the fuzzers with the \texttt{coverage} sanitizer enabled:

\begin{verbatim}
python3 infra/helper.py build_fuzzers \
  --sanitizer coverage "$PROJECT"
\end{verbatim}

Then, we use the OSS-Fuzz's coverage analysis tool, specifying the corpus directory and the target fuzzing harness:

\begin{verbatim}
python3 infra/helper.py coverage \
  --corpus-dir "build/work/\
    $PROJECT/fuzzing_corpus" \
  --fuzz-target "$HARNESS" \
  "$PROJECT" &
    \end{verbatim}

By default, the coverage tool starts a local web server to serve the HTML report. To ensure our script remains fully automated and headless, we run the coverage command in the background and poll the output directory (\texttt{build/out/\$PROJECT/report}) for up to 5 minutes, waiting until the report becomes available. Once generated, the HTML report directory is saved as \texttt{<timestamp>\_coverage\_{\{w,wo\}\_corpus}} and stored in the \texttt{submission} directory.

