As cited in the previous section, the default fuzzing harness, \texttt{input-fuzzer}, is limited to the user-interface-level input parser, leaving multiple essential tmux components completely untested.

The current harness has a very narrow scope: it only executes low-level input parsing functions with most of the codebase remaining untested. Based on coverage reports from both with-corpus ($14.00\%$ line coverage, $24.44\%$ function coverage, $13.41\%$ region coverage) and without-corpus ($13.94\%$ line coverage, $24.31\%$ function coverage, $13.35\%$ region coverage) runs, we can see that only input parsing, color formatting code and command parsing areas are covered in the current harness.

Multiple components of the tmux codebase are quite complex and difficult to test under a fuzzer; for example all the code areas that require multiple processes or threads or the use of sockets. A prominent example of such complex regions is the \texttt{client} and \texttt{server} subsystem: when tmux is launched, it either connects to an existing server or spawns one. The server, as defined in \texttt{server.c}, is a background process that handles all active sessions, panes and windows. Each user terminal runs a client process, defined in \texttt{client.c}, that communicates with the server using a UNIX-domain socket. Other code areas that are similarly complex might require a multiplexer runtime environment or execution of multiple commands in a command line environment, therefore they might be harder to test at a high level.

Fuzzing these complex code areas would demand creating real sockets, forking processes, and simulating terminal inputs, all of which pushes typical fuzzers beyond practical limits. Mocking a socket or using other fake implementations was not considered, as it would have required testing the functions in isolation and maintaining a separate and complex implementation just to simulate each component. This approach deviates from realistic tmux execution and would therefore lack testing integration bugs that might happen during the communications between client and server. Therefore the original authors preferred to focus on low level code areas that are simpler, more deterministic and do not require complex environments.

Several code areas remain uncovered by the current fuzzing harness, such as:
\begin{itemize}
    \item Screen and grid management code responsible for handling drawing operations, scrolling, and clipping on each terminal update
    \item Layout computation code that calculates pane sizes and positions for various tmux layout strategies (main-horizontal, even-horizontal, tiled, etc.)
    \item Window management code (creation, destruction, and layout of tmux windows and their buffers)
    \item Terminal capabilities handling
    \item Style formatting
    \item Event handling mechanisms
\end{itemize}

Most of these code regions are areas where users are less likely to supply malformed inputs directly. Therefore, we decided to focus on areas that are primary gatekeepers for user-supplied inputs:

\begin{itemize}
	%\item Client-server communication (\texttt{client.c} and \texttt{server.c})
    \item Command-line argument handling (\texttt{arguments.c})
	\item Command execution, command parsing logic and individual command modules (\texttt{cmd-parse.c} and \texttt{cmd-*.c} modules)
\end{itemize}

This lack of coverage is expected, as the harness never initializes a real tmux client or server, nor does it establish any socket-based communication so it does not test the application end to end. Instead, \texttt{input-fuzzer} simply creates a mock window and pane in-memory, and feeds them raw byte sequences generated by the fuzzing engine, as shown in \autoref{lst:input-fuzzer}.

\begin{lstlisting}[language=C,caption={Core of the `input-fuzzer` fuzzer code, including in-memory window and pane creation},label={lst:input-fuzzer}]
// Initialize the window and pane
w = window_create(PANE_WIDTH, PANE_HEIGHT, 0, 0
);
wp = window_add_pane(w, NULL, 0, 0);

// ...

// Process input and handle any error event
input_parse_buffer(wp, (u_char *)data, size);
while (cmdq_next(NULL) != 0);
error = event_base_loop(libevent, EVLOOP_NONBLOCK);
if (error == -1) errx(1, "event_base_loop failed");
\end{lstlisting}

Because no real client or server binary ever runs, the initialization, connection‑handling, and command‑dispatch code in both \texttt{client.c} and \texttt{server.c} is never reached. Likewise, none of the \texttt{cmd-*.c} handlers (e.g. \texttt{cmd-new-window.c}, \texttt{cmd-split-window.c}) ever see fuzzed input via the normal client‑server path as they are not executed in this environment. The code in \texttt{arguments.c} that handles command-line arguments is also bypassed entirely, representing a significant vulnerable code area that remains untested in the current implementation.


\subsection*{Region A: \textit{Arguments}}

The \texttt{arguments.c} file implements tmux's command-line argument parsing and handling system. This component plays a critical role in tmux's functionality by:

\begin{itemize}
  \item Processing all command-line parameters passed when tmux is launched
  \item Managing socket paths, configuration files, and control mode settings
  \item Providing utilities to validate and convert argument values
  \item Creating structured argument collections used throughout the program
\end{itemize}

This module is particularly important for security testing because it directly processes untrusted user input. Command-line arguments represent a classic attack vector for exploitation, with potential for path traversal, buffer overflows, or format string vulnerabilities if input validation is insufficient.

Our analysis of the coverage reports confirms that the existing fuzzing harness achieves only about 5.8\% line coverage of \texttt{arguments.c}. Examining the harness code in \texttt{input-fuzzer.c} reveals several fundamental reasons for this limited coverage:

\begin{itemize}
  \item \textbf{Initialization architecture}: The fuzzer initializes a minimal tmux environment with just a window and pane object, bypassing the normal program entry point. In the \texttt{LLVMFuzzerInitialize} function, it creates basic global structures but never invokes the argument parser.

  \item \textbf{Input delivery method}: The fuzzer sends data directly to \texttt{input\_parse\_buffer()} rather than through the main command-line argument system. While some command parsing may indirectly invoke \texttt{args\_parse()}, the full structured command-line handling is not properly exercised.

  \item \textbf{Process lifecycle}: LibFuzzer's design maintains a persistent process, calling the \texttt{LLVMFuzzerTestOneInput} function repeatedly on the same process. However, command-line arguments are typically processed once during program initialization, making this model ineffective for testing argument handling.

  \item \textbf{Environment isolation}: The fuzzer runs in a controlled container environment without access to the filesystem or socket resources that many argument-handling functions interact with, leaving code paths like \texttt{args\_check\_socket()} and \texttt{args\_load\_cfg()} untested.
\end{itemize}

Looking at specific uncovered functions in the coverage reports, we observe that critical sections like \texttt{args\_parse()}, \texttt{args\_find()}, and \texttt{args\_escape()} show zero execution counts. Additionally, complex features such as the percentage-based size calculations in \texttt{args\_percentage()} remain completely unexplored by the fuzzer.

\subsection*{Region B: \textit{Command Parsing}}

The \texttt{cmd-parse.c} file implements tmux's command parser, which is responsible for converting textual commands into executable structures. This component:

\begin{itemize}
  \item Processes commands from interactive user input, configuration files, and scripts
  \item Handles complex language features including quoting, variable expansion, and command chaining
  \item Validates command syntax and semantics before execution
  \item Resolves targets for commands (session, window, and pane specifiers)
\end{itemize}

The command parser is a critical security boundary as it processes input from multiple sources including configuration files that may contain untrusted content. Vulnerabilities in this component could potentially lead to command injection or denial of service issues.

The command parse file is implemented in the code as a \textit{Yacc} (\textit{Yet Another Compiler Compiler}) parser file, so as a \texttt{cmd-parse.y} file that will be compiled into a \texttt{.c} file. The \texttt{cmd-parse.c} has some high level functions that interacts with and dispatches functionality to various \texttt{cmd-*.c} files, each of which implements a specific tmux command. Most of such specific command files are not touched by the current harness even though they represent some of the core operational logic of individual tmux commands and therefore could constitute a prime fuzzing target.

Our coverage analysis shows that despite \texttt{cmd-parse.c} having better coverage than most tmux components at approximately 27\% line coverage, significant portions remain untested. Examining the harness structure explains these gaps:

\begin{itemize}
  \item \textbf{Missing server context}: The existing harness establishes a basic pane and window environment but lacks the full server infrastructure. The coverage report reveals that code paths requiring interaction with server data structures (like session and client management) show zero execution counts.

  \item \textbf{Limited tokenization}: While the harness does invoke \texttt{input\_parse\_buffer()}, which eventually leads to some command parsing, the randomized fuzzing input rarely satisfies the tokenizer's grammar requirements. Examining uncovered regions in the report shows most advanced parsing features like variable expansion (\texttt{\$\{...\}}), escape sequences (line 3400-3404), and quoted strings (lines 3419-3438) are never executed.

  \item \textbf{Command structure limitations}: The harness creates a minimal command environment, but many commands in tmux expect to interact with other subsystems. For example, conditional command execution (\texttt{\%if} blocks) shows zero coverage in the report.

  \item \textbf{Tokenization barriers}: The parser's design expects structured input with properly quoted strings, escape sequences, and command chaining. From the coverage report, we can see that error paths like the ones at lines 3454-3457 are never reached because random inputs fail at earlier validation stages.
\end{itemize}

Even in more heavily covered sections of the file, the coverage is often limited to simple path validation without exploring deeper conditional branches. For instance, while the basic token reading loop (lines 3290-3448) shows some coverage, most of the specialized command handling branches within it remain untested.
