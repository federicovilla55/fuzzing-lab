\documentclass[11pt,a4paper,twocolumn]{article}

% Title and authors
\title{%
  CS-412 Software Security Lab 2\\[0.5em]
  \Large Fuzzing Lab Report\\
  Spring Semester 2025\\[0.5em]
  Project: Tmux
}

\author{%
  Luca Di Bello (SCIPER 367552)
  Federico Villa (SCIPER XYZ) \\
  Noah El Hassanie (SCIPER 404885)
  Cristina Morad (SCIPER 405241) \\
}
\date{Submitted: May 8, 2025}

% Load custom styl
\usepackage{report_style}

\begin{document}
\maketitle

\begin{abstract}
	In this lab, we integrate and evaluate a fuzzing harness for the \texttt{tmux} terminal
	multiplexer using Google’s OSS-Fuzz infrastructure. We first establish a baseline
	by measuring line coverage of the existing \texttt{tmux\_fuzzer} both with and without the
	provided seed corpus, observing a significant coverage boost when seeds are present.

	We then identify two major code regions not exercised by the baseline harness, implement
	targeted harness improvements to cover those regions, and finally triage a crash uncovered
	in the session-detach logic, proposing a patch and assessing its exploitability.
\end{abstract}

\section{Introduction}

Fuzzing is a proven technique for uncovering memory‐safety and logic bugs in C/C++ code. In this assignment we chose \texttt{tmux}, an open-source terminal multiplexer for Unix-like systems, as our target because it (1) has a relatively small OSS-Fuzz integration (only one harness), (2) shows very low runtime coverage, and (3) is widely used daily by developers and DevOps engineers across countless systems.  By improving its fuzzing harness, we aim both to increase \texttt{tmux}’s coverage under OSS-Fuzz and to demonstrate how targeted harness modifications can uncover real bugs in a piece of critical infrastructure.

\section{Methodology}

Experiments were conducted on Ubuntu 22.04 LTS with Docker 20.10 and Python 3.10. We used a local fork of OSS-Fuzz in \texttt{forks/oss-fuzz} and the \texttt{tmux} seed corpus in \texttt{forks/tmux-fuzzing-corpus}. Two bash scripts (\texttt{run\_w\_corpus.sh} and \texttt{run\_wo\_corpus.sh}) automate each 4 h campaign. The main steps are as follows:

\textbf{Reset build and cleanup:} the script will first reset the build scripts to the latest version using the \texttt{git reset ---hard} command. This ensures that the user is working with a clean slate (without any modifications from previous runs). Furthermore, all files in the \texttt{build/out} directory are removed to ensure that the user is working with a clean build environment.

\textbf{Apply patch:} the user is running the fuzzing campaign without the seed corpus, the script will apply a git patch named \texttt{remove\_seed\_corpus.patch}. This patch will remove the seed corpus from the build scripts, ensuring that the fuzzing campaign runs without any pre-existing input seeds.

\textbf{Build with coverage:} in order to build the fuzzing harness with coverage instrumentation, we use the \texttt{build\_image} and \texttt{build\_fuzzers} commands from the \texttt{helper.py} script.

\begin{verbatim}
cd forks/oss-fuzz
python3 infra/helper.py build_image \
  tmux --pull
python3 infra/helper.py build_fuzzers \
  --sanitizer coverage tmux
\end{verbatim}

The \texttt{--sanitizer coverage} flag ensures that the fuzzing harness is built with coverage instrumentation, allowing us to measure the code coverage during the fuzzing campaign.

\textbf{Prepare corpus:}

\begin{itemize}
	\item Seeded run: copy all files from \texttt{forks/tmux-fuzzing-corpus} into \texttt{build/out/corpus}.
	\item Unseeded run: ensure \texttt{build/out/corpus} is empty.
\end{itemize}

\textbf{Run fuzzing campaign:} the script will run the fuzzing campaign using the \texttt{run\_fuzzer} command from the \texttt{helper.py} script. The \texttt{---max\_total\_time} flag is set to 14400 seconds (4 hours) to limit the duration of the fuzzing campaign.

\begin{verbatim}
python3 infra/helper.py run_fuzzer \
  --engine libfuzzer tmux \
  --corpus-dir build/out/corpus \
  input-fuzzer -- \
  -max_total_time=14400 \
  -timeout=25 \
  -print_final_stats=1 \
  -artifact_prefix=./crashes \
  -jobs=$(nproc) \
  -workers=0
\end{verbatim}

\textbf{Generate coverage:} finally, the script will generate the coverage report using the \texttt{coverage} command from the \texttt{helper.py} script, and copy the coverage report to the \texttt{assignment/part\_1} directory.

\begin{verbatim}
python3 infra/helper.py coverage \
  tmux \
  --corpus-dir build/out/corpus \
  --fuzz-target input-fuzzer
\end{verbatim}

The \texttt{---corpus-dir} flag is set to \texttt{build/out/corpus} to ensure that the coverage report is generated using the same corpus used during the fuzzing campaign.

\section{Part 1: Baseline Evaluation}

\subsection{With Seed Corpus}

List the exact build/run commands and point to \texttt{run\_w\_corpus.sh}.

\subsection{Without Seed Corpus}
List the exact build/run commands and point to \texttt{run\_wo\_corpus.sh}.

\subsection{Coverage Comparison}
Discuss coverage percentages and key observations.

\section{Part 2: Coverage Gaps}
By analyzing the OSS-Fuzz introspector, we observed that several regions are not covered by the current fuzzer. Two significant uncovered regions are \texttt{client.c} and \texttt{server.c}. In the following subsections, we justify their relevance and explain the shared limitations of the current fuzzing harness that prevent them from being covered.

\subsection{Region A: \texttt{client.c} – Justification of Significance}
The \texttt{client.c} file implements the logic for launching a tmux client, connecting to the tmux server via a UNIX socket, and sending user commands for execution. This file is crucial because any malformed command-line input or unexpected interaction with the server could lead to vulnerabilities or instability. Testing this area is essential to ensure the robustness of the client-side logic, particularly because it processes direct user input.

\subsection{Region B: \texttt{server.c} – Justification of Significance}
The \texttt{server.c} file contains the core logic for accepting client connections, managing sessions, and dispatching commands. It includes the entry point for the server loop and handles critical functionality such as authentication, command execution, and process management. Bugs or vulnerabilities in this region could be exploited by malicious clients to crash the server.

\subsection*{Shared Explanation of Coverage Shortcomings}
The existing fuzzing harness, \texttt{input-fuzzer}, operates within a simulated tmux environment by directly creating a mock window and pane, and parsing raw input as if it were typed into an active terminal. However, this harness does not instantiate a real tmux client or server, nor does it set up socket-based communication between the two.

As a result, any code related to the actual startup of the client process (\texttt{client.c}) or the server's handling of connections and command dispatching (\texttt{server.c}) lies entirely outside the execution scope of the current harness. These components are only triggered in a full client-server lifecycle, which is not simulated or exercised by the current fuzzing setup. Therefore, the input-fuzzer is fundamentally limited to user-interface-level input processing, leaving the network and process-management layers untested.

\section{Part 3: Fuzzer Improvements}

\subsection{Improvement 1 (Region A)}
Describe changes, refer to \texttt{improve1/run\_improve1.sh}, and summarize coverage delta.

\subsection{Improvement 2 (Region B)}
Describe changes, refer to \texttt{improve2/run\_improve2.sh}, and summarize coverage delta.

\section{Part 4: Crash Analysis}
Detail crash reproduction (\texttt{run\_poc.sh}), ASAN log snippet, root cause, proposed patch, and exploitability.

\section{Conclusion and Future Work}
Summarize achievements and outline possible next steps.

\printbibliography

\end{document}
