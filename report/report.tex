\documentclass[11pt,a4paper,twocolumn]{article}

% Title and authors
\title{%
  CS-412 Software Security Lab 2\\[0.5em]
  \Large Fuzzing Lab Report\\
  Spring Semester 2025\\[0.5em]
  Project: Tmux
}

\author{%
  Luca Di Bello (SCIPER 367552)
  Federico Villa (SCIPER 386986) \\
  Noah El Hassanie (SCIPER 404885)
  Cristina Morad (SCIPER 405241) \\
}
\date{Submitted: May 8, 2025}

% Load custom styl
\usepackage{report_style}

\begin{document}
\maketitle

\begin{abstract}
	In this lab, we integrate and evaluate a fuzzing harness for the \texttt{tmux} terminal
	multiplexer using Google’s OSS-Fuzz infrastructure. We first establish a baseline
	by measuring line coverage of the existing \texttt{tmux\_fuzzer} both with and without the
	provided seed corpus, observing similar results in both cases.

	We then identify two major code regions not exercised by the baseline harness, implemented
	targeted harness improvements to cover those regions, and finally triage a crash uncovered
	in the session-detach logic, proposing a patch and assessing its exploitability.
\end{abstract}

\section{Introduction}

Fuzzing is a proven technique for uncovering memory‐safety and logic bugs in C/C++ code. In this assignment we chose \texttt{tmux}, an open-source terminal multiplexer for Unix-like systems, as our target because it (1) has a relatively small OSS-Fuzz integration (only one harness), (2) shows very low runtime coverage, and (3) is widely used daily by developers and DevOps engineers across countless systems.  By improving its fuzzing harness, we aim both to increase \texttt{tmux}’s coverage under OSS-Fuzz and to demonstrate how targeted harness modifications can uncover real bugs in a piece of critical infrastructure.

\section{Methodology}
\label{sec:methodology}

All experiments were conducted on a Debian system running Linux kernel 6.1 (LTS), using Docker 28.1.1 and Python 3.11. We maintain a local fork of OSS-Fuzz under \texttt{forks/oss-fuzz}. Two helper scripts (\texttt{run\_w\_corpus.sh} and \texttt{run\_wo\_corpus.sh}) each run a 4 hour fuzzing campaign (seeded vs. unseeded fuzzing) and then produce coverage reports. The scripts are located in \texttt{submission/part\_1} and are invoked as follows:

\noindent \paragraph{Configuration} \label{sec:methodology_configuration} Both scripts are highly configurable and can be run with different parameters. The following variables are set at the top of each script:
\begin{itemize}
	\item \texttt{PROJECT=tmux} - OSS-Fuzz project name
	\item \texttt{HARNESS=input-fuzzer} - name of the project's fuzzing harness to run
	\item \texttt{ENGINE=libfuzzer} - engine to use (tmux supports \texttt{libfuzzer}, \texttt{afl++} and \texttt{honggfuzz})
	\item \texttt{SANITIZER=address} - Sanitizer to use. Available options: \texttt{address} (ASan), \texttt{undefined} (UBSan), \texttt{none} (disabled). \cite{oss-fuzz:tmux_project_yaml}
	\item \texttt{REBUILD=true} - controls whether to rebuild the OSS-Fuzz image from scratch.
	\item \texttt{RUNTIME=14400} - fuzzing time in seconds (by default 4 hours).
	\item \texttt{FLAGS="-max\_total\_time=\$RUNTIME -timeout=25 -print\_final\_stats=1 -artifact\_prefix=./crashes"} - fuzzer engine flags (refer to the documentation of the engine for more details).
	\item \texttt{OSS\_FUZZ\_DIR="forks/oss-fuzz/build"} (\emph{optional}) – this variable is set by default to match the current repository structure. However, it is still explicitly defined to allow advanced users to override it if they wish to customize the script for their own needs (e.g. use a different fork of OSS-Fuzz).
\end{itemize}

\noindent \textbf{Clean build directory} If \texttt{\$REBUILD} is true, we remove the entire \texttt{forks/oss-fuzz/build} directory as follows:

\begin{verbatim}
rm -rf "$OSS_FUZZ_DIR/build" || true
\end{verbatim}

This ensures no stale build artifacts remain and that the build process starts from a clean slate.

\noindent \paragraph{Apply patch (unseeded only)} In \texttt{run\_wo\_corpus.sh} we remove the seed corpus from the Docker image and the build script to ensure the fuzzer starts with no initial input files, thus avoiding any bias introduced by pre-seeding the fuzzer with a starting corpus.

To achieve this, we apply a patch \texttt{remove\_seed\_corpus.patch} using the \texttt{git apply} command, which modifies the project's \texttt{Dockerfile} and \texttt{build.sh} to execlude the seed corpus during the build process:

\begin{verbatim}
git apply submission/part_1/
  remove_seed_corpus.patch
\end{verbatim}

\noindent \paragraph{Build OSS-Fuzz image and fuzzers} To prepare the fuzzing environment, we use the OSS-Fuzz helper script \texttt{helper.py} to build the Docker image and compile the fuzzers with the specified sanitizer (e.g., ASan, UBSan, none).

Before building the Docker image, the script checks whether rebuilding is required by evaluating the \texttt{\$REBUILD} variable (refer to \autoref{sec:methodology_configuration} for more details on the script configuration). If it is set to \texttt{true}, the following command is executed to build the Docker image for the configured project:

\begin{verbatim}
cd "$OSS_FUZZ_DIR"
python3 infra/helper.py build_image \
  "$PROJECT" --pull
\end{verbatim}

The \texttt{---pull} flag ensures that the latest version of the OSS-Fuzz base Docker image is used. This is essential to ensure compatibility with the latest updates, bug fixes, and dependency changes.

Regardless of the \texttt{\$REBUILD} variable, the script always rebuilds the fuzzers with the specified sanitizer using the following command:

\begin{verbatim}
python3 infra/helper.py build_fuzzers \
  "$PROJECT" --sanitizer "$SANITIZER" 
\end{verbatim}

This command compiles the fuzzers for the specified project, applying the selected sanitizer to instrument the code for better error detection and reporting. This generates the fuzzing binaries under \texttt{build/out/\$PROJECT}, which are later needed to run the fuzzing campaigns.

\noindent \paragraph{Prepare corpus directory}

By default, both scripts rely on \texttt{build/work/\$PROJECT/fuzzing\_corpus} as the input corpus directory (refer to \autoref{sec:methodology_configuration} for more details). For seeded runs, this directory is automatically populated by the unpatched \texttt{tmux}'s build scripts with files from the official \href{https://github.com/tmux/tmux-fuzzing-corpus/}{\texttt{tmux-fuzzing-corpus}} repository. This corpus provides a comprehensive set of input samples to simulate real-world usage scenarios and edge cases across different terminal emulators (currently only \href{https://iterm2.com/}{iTerm} and \href{https://alacritty.org/}{Alacritty}), including various terminal escape sequences and control characters. \cite{tmux:tmux-fuzzing-corpus}

On the other hand, during unseeded runs we ensure that the directory containing the seed corpus is empty. Even if the build script and Dockerfile are patched to exclude the seed corpus, the directory could still contain files from previous seeded runs. To ensure a clean state, we delete the \texttt{fuzzing\_corpus} directory and recreate it empty. In summary:

\begin{itemize}
	\item \emph{Seeded run:} leave whatever files OSS-Fuzz has placed there.
	\item \emph{Unseeded run:} delete and recreate it empty:
	      \begin{verbatim}
rm -rf "$CORPUS_DIR" || true
mkdir -p "$CORPUS_DIR/crashes"
\end{verbatim}
\end{itemize}

By default, we configured LibFuzzer to ensure that all crash-inducing inputs are stored within the designated \texttt{crashes} subdirectory. This is done by setting the \texttt{---artifact\_prefix} flag to \texttt{./crashes} in the \texttt{\$FLAGS} variable (refer to \autoref{sec:methodology_configuration} for more details). This allows us to easily access and analyze any inputs that caused the target program to crash during the fuzzing process.

\noindent \paragraph{Run the fuzzer (4 h).}

\begin{verbatim}
python3 infra/helper.py run_fuzzer \
  --engine "$ENGINE" \
  --corpus-dir "build/work/$PROJECT/fuzzing_corpus" \
  "$PROJECT" "$HARNESS" -- $FLAGS
    \end{verbatim}

\noindent \paragraph{Stop Docker.}
After fuzzing we clean up any running containers:
\begin{verbatim}
docker stop "$(docker ps -q)" || true
    \end{verbatim}

\noindent \paragraph{Export the corpus.}
Timestamp and zip the resulting corpus into \texttt{experiments/}\(\langle\)ts\(\rangle\)\texttt{\_w\_corpus.zip} (or \texttt{\_wo\_corpus.zip}) for later analysis.

\textbf{Generate coverage report.}
We rebuild the fuzzers with coverage instrumentation:
\begin{verbatim}
python3 infra/helper.py build_fuzzers --sanitizer coverage "$PROJECT"
    \end{verbatim}
Then invoke OSS-Fuzz’s coverage tool:
\begin{verbatim}
python3 infra/helper.py coverage \
  --corpus-dir "build/work/$PROJECT/fuzzing_corpus" \
  --fuzz-target "$HARNESS" \
  "$PROJECT" &
    \end{verbatim}
We poll \texttt{build/out/\$PROJECT/report} (up to 5 min) until the HTML is ready.

\textbf{Export coverage.}
Finally, we stop any remaining containers again and copy the fully generated
coverage report from \texttt{build/out/\$PROJECT/report} into
\texttt{submission/part\_1/\(\langle\)ts\(\rangle\)\_coverage\_{\{w,wo\}\_corpus}}.

\section{Part 1: Baseline Evaluation}

\subsection{With Seed Corpus}

List the exact build/run commands and point to \texttt{run\_w\_corpus.sh}.

\subsection{Without Seed Corpus}
List the exact build/run commands and point to \texttt{run\_wo\_corpus.sh}.

\subsection{Coverage Comparison}
Discuss coverage percentages and key observations.

\section{Part 2: Coverage Gaps}
By analyzing the OSS-Fuzz introspector, we observed that several regions are not covered by the current fuzzer. Two significant uncovered regions are \texttt{client.c} and \texttt{server.c}. In the following subsections, we justify their relevance and explain the shared limitations of the current fuzzing harness that prevent them from being covered.

\subsection{Region A: \texttt{client.c} – Justification of Significance}
The \texttt{client.c} file implements the logic for launching a tmux client, connecting to the tmux server via a UNIX socket, and sending user commands for execution. This file is crucial because any malformed command-line input or unexpected interaction with the server could lead to vulnerabilities or instability. Testing this area is essential to ensure the robustness of the client-side logic, particularly because it processes direct user input.

\subsection{Region B: \texttt{server.c} – Justification of Significance}
The \texttt{server.c} file contains the core logic for accepting client connections, managing sessions, and dispatching commands. It includes the entry point for the server loop and handles critical functionality such as authentication, command execution, and process management. Bugs or vulnerabilities in this region could be exploited by malicious clients to crash the server.

\subsection*{Shared Explanation of Coverage Shortcomings}
The existing fuzzing harness, \texttt{input-fuzzer}, operates within a simulated tmux environment by directly creating a mock window and pane, and parsing raw input as if it were typed into an active terminal. However, this harness does not instantiate a real tmux client or server, nor does it set up socket-based communication between the two.

As a result, any code related to the actual startup of the client process (\texttt{client.c}) or the server's handling of connections and command dispatching (\texttt{server.c}) lies entirely outside the execution scope of the current harness. These components are only triggered in a full client-server lifecycle, which is not simulated or exercised by the current fuzzing setup. Therefore, the input-fuzzer is fundamentally limited to user-interface-level input processing, leaving the network and process-management layers untested.

\section{Part 3: Fuzzer Improvements}

\subsection{Improvement 1 (Region A)}
Describe changes, refer to \texttt{improve1/run\_improve1.sh}, and summarize coverage delta.

\subsection{Improvement 2 (Region B)}
Describe changes, refer to \texttt{improve2/run\_improve2.sh}, and summarize coverage delta.

\section{Part 4: Crash Analysis}
Detail crash reproduction (\texttt{run\_poc.sh}), ASAN log snippet, root cause, proposed patch, and exploitability.

\section{Conclusion and Future Work}
Summarize achievements and outline possible next steps.

\printbibliography

\end{document}
