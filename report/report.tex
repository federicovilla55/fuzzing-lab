\documentclass[11pt,a4paper,twocolumn]{article}

% Title and authors
\title{%
  CS-412 Software Security Lab 2\\[0.5em]
  \Large Fuzzing Lab Report\\
  Spring Semester 2025\\[0.5em]
  Project: Tmux
}

\author{%
  Luca Di Bello (SCIPER 367552)
  Federico Villa (SCIPER 386986) \\
  Noah El Hassanie (SCIPER 404885)
  Cristina Morad (SCIPER 405241) \\
}
\date{Submitted: May 8, 2025}

% Load custom styl
\usepackage{report_style}

\begin{document}
\maketitle

\begin{abstract}
	In this lab, we integrate and evaluate a fuzzing harness for the \texttt{tmux} terminal
	multiplexer using Google’s OSS-Fuzz infrastructure. We first establish a baseline
	by measuring line coverage of the existing \texttt{tmux\_fuzzer} both with and without the
	provided seed corpus, observing similar results in both cases.

	We then identify two major code regions not exercised by the baseline harness, implemented
	targeted harness improvements to cover those regions, and finally triage a crash uncovered
	in the session-detach logic, proposing a patch and assessing its exploitability.
\end{abstract}

\section{Introduction}

Fuzzing is a proven technique for uncovering memory‐safety and logic bugs in C/C++ code. In this assignment we chose \texttt{tmux}, an open-source terminal multiplexer for Unix-like systems, as our target because it (1) has a relatively small OSS-Fuzz integration (only one harness), (2) shows very low runtime coverage, and (3) is widely used daily by developers and DevOps engineers across countless systems.  By improving its fuzzing harness, we aim both to increase \texttt{tmux}’s coverage under OSS-Fuzz and to demonstrate how targeted harness modifications can uncover real bugs in a piece of critical infrastructure.

\section{Methodology}

All experiments were performed on Ubuntu 22.04 LTS with Docker 20.10 and Python 3.10. We maintain a local fork of OSS-Fuzz under \texttt{forks/oss-fuzz}. Two helper scripts (\texttt{run\_w\_corpus.sh} and \texttt{run\_wo\_corpus.sh}) each run a 4 h fuzzing campaign (seeded vs.\ unseeded) and then produce coverage reports. Each script follows the same high-level steps:

\begin{enumerate}
	\item \textbf{Configuration.}
	      At the top of the script we set:
	      \begin{itemize}
		      \item \texttt{PROJECT=tmux}, \texttt{HARNESS=input-fuzzer}, \texttt{ENGINE=libfuzzer}
		      \item \texttt{SANITIZER=address} (or \texttt{undefined} for uninstrumented runs)
		      \item \texttt{REBUILD=true} controls whether to wipe previous build artifacts
		      \item \texttt{RUNTIME=14400} (fuzz for 4 h) and
		            \texttt{FLAGS="-max\_total\_time=\$RUNTIME -timeout=25 -print\_final\_stats=1 -artifact\_prefix=./crashes"}.
	      \end{itemize}

	\item \textbf{Clean build directory.}
	      If \texttt{\$REBUILD} is true, we remove the entire \texttt{forks/oss-fuzz/build} directory:
	      \begin{verbatim}
rm -rf "$OSS_FUZZ_DIR/build" || true
    \end{verbatim}
	      This ensures no stale build artifacts remain.

	\item \textbf{Apply patch (unseeded only).}
	      In \texttt{run\_wo\_corpus.sh} we apply
	      \texttt{submission/part\_1/remove\_seed\_corpus.patch} so that the OSS-Fuzz build scripts no longer package any initial seeds:
	      \begin{verbatim}
git apply submission/part_1/remove_seed_corpus.patch
    \end{verbatim}

	\item \textbf{Build OSS-Fuzz image and fuzzers.}
	      \begin{verbatim}
cd "$OSS_FUZZ_DIR"
python3 infra/helper.py build_image "$PROJECT" --pull
python3 infra/helper.py build_fuzzers --sanitizer "$SANITIZER" "$PROJECT"
    \end{verbatim}

	\item \textbf{Prepare corpus directory.}
	      Both scripts use
	      \texttt{build/work/\$PROJECT/fuzzing\_corpus} as the input corpus:
	      \begin{itemize}
		      \item \emph{Seeded run:} leave whatever files OSS-Fuzz has placed there.
		      \item \emph{Unseeded run:} delete and recreate it empty:
		            \begin{verbatim}
rm -rf "$CORPUS_DIR" || true
mkdir -p "$CORPUS_DIR/crashes"
\end{verbatim}
	      \end{itemize}

	\item \textbf{Run the fuzzer (4 h).}
	      \begin{verbatim}
python3 infra/helper.py run_fuzzer \
  --engine "$ENGINE" \
  --corpus-dir "build/work/$PROJECT/fuzzing_corpus" \
  "$PROJECT" "$HARNESS" -- $FLAGS
    \end{verbatim}

	\item \textbf{Stop Docker.}
	      After fuzzing we clean up any running containers:
	      \begin{verbatim}
docker stop "$(docker ps -q)" || true
    \end{verbatim}

	\item \textbf{Export the corpus.}
	      Timestamp and zip the resulting corpus into \texttt{experiments/}\(\langle\)ts\(\rangle\)\texttt{\_w\_corpus.zip} (or \texttt{\_wo\_corpus.zip}) for later analysis.

	\item \textbf{Generate coverage report.}
	      We rebuild the fuzzers with coverage instrumentation:
	      \begin{verbatim}
python3 infra/helper.py build_fuzzers --sanitizer coverage "$PROJECT"
    \end{verbatim}
	      Then invoke OSS-Fuzz’s coverage tool:
	      \begin{verbatim}
python3 infra/helper.py coverage \
  --corpus-dir "build/work/$PROJECT/fuzzing_corpus" \
  --fuzz-target "$HARNESS" \
  "$PROJECT" &
    \end{verbatim}
	      We poll \texttt{build/out/\$PROJECT/report} (up to 5 min) until the HTML is ready.

	\item \textbf{Export coverage.}
	      Finally, we stop any remaining containers again and copy the fully generated
	      coverage report from \texttt{build/out/\$PROJECT/report} into
	      \texttt{submission/part\_1/\(\langle\)ts\(\rangle\)\_coverage\_{\{w,wo\}\_corpus}}.
\end{enumerate}

\section{Part 1: Baseline Evaluation}

\subsection{With Seed Corpus}

List the exact build/run commands and point to \texttt{run\_w\_corpus.sh}.

\subsection{Without Seed Corpus}
List the exact build/run commands and point to \texttt{run\_wo\_corpus.sh}.

\subsection{Coverage Comparison}
Discuss coverage percentages and key observations.

\section{Part 2: Coverage Gaps}
By analyzing the OSS-Fuzz introspector, we observed that several regions are not covered by the current fuzzer. Two significant uncovered regions are \texttt{client.c} and \texttt{server.c}. In the following subsections, we justify their relevance and explain the shared limitations of the current fuzzing harness that prevent them from being covered.

\subsection{Region A: \texttt{client.c} – Justification of Significance}
The \texttt{client.c} file implements the logic for launching a tmux client, connecting to the tmux server via a UNIX socket, and sending user commands for execution. This file is crucial because any malformed command-line input or unexpected interaction with the server could lead to vulnerabilities or instability. Testing this area is essential to ensure the robustness of the client-side logic, particularly because it processes direct user input.

\subsection{Region B: \texttt{server.c} – Justification of Significance}
The \texttt{server.c} file contains the core logic for accepting client connections, managing sessions, and dispatching commands. It includes the entry point for the server loop and handles critical functionality such as authentication, command execution, and process management. Bugs or vulnerabilities in this region could be exploited by malicious clients to crash the server.

\subsection*{Shared Explanation of Coverage Shortcomings}
The existing fuzzing harness, \texttt{input-fuzzer}, operates within a simulated tmux environment by directly creating a mock window and pane, and parsing raw input as if it were typed into an active terminal. However, this harness does not instantiate a real tmux client or server, nor does it set up socket-based communication between the two.

As a result, any code related to the actual startup of the client process (\texttt{client.c}) or the server's handling of connections and command dispatching (\texttt{server.c}) lies entirely outside the execution scope of the current harness. These components are only triggered in a full client-server lifecycle, which is not simulated or exercised by the current fuzzing setup. Therefore, the input-fuzzer is fundamentally limited to user-interface-level input processing, leaving the network and process-management layers untested.

\section{Part 3: Fuzzer Improvements}

\subsection{Improvement 1 (Region A)}
Describe changes, refer to \texttt{improve1/run\_improve1.sh}, and summarize coverage delta.

\subsection{Improvement 2 (Region B)}
Describe changes, refer to \texttt{improve2/run\_improve2.sh}, and summarize coverage delta.

\section{Part 4: Crash Analysis}
Detail crash reproduction (\texttt{run\_poc.sh}), ASAN log snippet, root cause, proposed patch, and exploitability.

\section{Conclusion and Future Work}
Summarize achievements and outline possible next steps.

\printbibliography

\end{document}
